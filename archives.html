<!DOCTYPE html>
<html>

<head>
  <title>welcome to the archives</title>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="files/favicon.png"/>
  <style>
    @font-face {
      font-family: 'Menlo';
      font-style: normal;
      src:
        local('Menlo'),
        local('Menlo Regular'),
        url('../fonts/Menlo.otf') format("opentype");
    }

    body {
      margin: 0px;
      width: 100vw;
      height: 100vh;
      background-color: black;
      font-family: 'Menlo', monospace;
      font-size: 10px;
    }

    .cell {
      position: absolute;
      overflow: hidden;
      color: gray;
      /*transition: color 0.5s, transform 0.5s, opacity 3s;*/
    }

    .cell:hover {
      /*color: lime;*/
      /*transform: scale(1.02, 1.02);*/
    }

    .block {
      width: 100%;
      height: 100%;
      margin: 0px;
      text-align: justify;
    }

    .line {
      text-align-last: justify;
    }
  </style>
</head>

<body>
</body>

<script src="libraries/natalie.js"></script>
<script src="files/iliad.js"></script>
<script src="files/odyssey.js"></script>
<script src="files/aeneid.js"></script>
<script src="files/metamorphoses.js"></script>
<script src="files/de-rerum-natura.js"></script>
<script src="files/paradise-lost.js"></script>
<script src="files/idylls-of-the-king.js"></script>

<script>
  var corpora = [iliad, odyssey, aeneid, metamorphoses, deRerumNatura, paradiseLost, idyllsOfTheKing];
  var corpus = corpora.reduce((x, y) => x.concat(y));

  var splitCorpusByWords = true;

  if (splitCorpusByWords) {
    corpus = corpus.join(' ').split(' ');
  }

  var lineDuration       =  2000;
  var paragraphDuration  =  1000;
  var cycleDuration      = 10000;
  var delayBetweenCycles =  1000;

  var variableFontSize = true;

  typeDirection   = true;
  untypeDirection = false;

  var width  = window.innerWidth;
  var height = window.innerHeight;

  var margin = 30;

  var columnWidth, rowHeight, cells;

  cycle();

  function cycle() {
    var columns = randomIntegerInclusive(2, 7);
    var rows    = randomIntegerInclusive(2, 5);
    // var columns = 6;
    // var rows    = 5;
    // var columns = 1;
    // var rows    = 1;

    columnWidth = (width - margin * (columns + 1)) / columns;
    rowHeight   = (height - margin * (rows + 1)) / rows;

    var merged = Math.floor(randomFloat(0.4, 1.0) * columns * rows);

    createGrid(columns, rows);
    mergeSomeCells(merged);

    fillAllCells(true);
    // fillAllCells(false);

    setTimeout(clearGrid, cycleDuration);
    checkIfEmpty();
  }

  function checkIfEmpty() {
    setTimeout(function() {
      cells = document.getElementsByClassName('cell');
      if (cells.length == 0) {
        setTimeout(cycle, delayBetweenCycles);
      } else {
        checkIfEmpty();
      }
    }, 100);
  }

  function createGrid(columns, rows) {
    for (var j = 0; j < rows; j++) {
      for (var i = 0; i < columns; i++) {
        var cell = document.createElement('div');
        cell.className = 'cell';

        cell.style.width    = columnWidth + 'px';
        cell.style.height   = rowHeight + 'px';
        cell.style.margin   = margin / 2 + 'px';

        if (variableFontSize) {
          cell.style.fontSize = randomIntegerInclusive(8, 13) + 'px';
        }

        var cellLeft = i * columnWidth;
        var cellTop  = j * rowHeight;

        if (i == 0) {
          cell.style.marginLeft = margin + 'px';
        } else {
          cellLeft += margin * (i + 0.5);
        }

        if (i == columns - 1) {
          cell.style.marginRight = margin + 'px';
        }

        if (j == 0) {
          cell.style.marginTop = margin + 'px';
        } else {
          cellTop += margin * (j + 0.5);
        }

        if (j == rows - 1) {
          cell.style.marginBottom = margin + 'px';
        }

        cell.style.left = cellLeft + 'px';
        cell.style.top  = cellTop + 'px';

        document.body.appendChild(cell);
      }
    }
  }

  function adjacentHorizontal(cell1, cell2) {
    var rect1 = cell1.getBoundingClientRect();
    var rect2 = cell2.getBoundingClientRect();

    var nextColumn = rect2.left - rect1.right == margin;
    var sameRow    = rect1.top == rect2.top && rect1.bottom == rect2.bottom;

    return nextColumn && sameRow;
  }

  function adjacentVertical(cell1, cell2) {
    var rect1 = cell1.getBoundingClientRect();
    var rect2 = cell2.getBoundingClientRect();

    var nextRow    = rect2.top - rect1.bottom == margin;
    var sameColumn = rect1.left == rect2.left && rect1.right == rect2.right;

    return nextRow && sameColumn;
  }

  function merge(cell1, cell2, direction) {
    var rect1 = cell1.getBoundingClientRect();
    var rect2 = cell2.getBoundingClientRect();

    var marginLeft   = cell1.style.marginLeft;
    var marginRight  = cell2.style.marginRight;
    var marginTop    = cell1.style.marginTop;
    var marginBottom = cell2.style.marginBottom;

    var left = rect1.left - parseFloat(marginLeft);
    var top  = rect1.top  - parseFloat(marginTop);

    if (direction) {
      var width  = rect1.width + margin + rect2.width;
      var height = rect1.height;
    } else {
      var width  = rect1.width;
      var height = rect1.height + margin + rect2.height;
    }

    var newCell = document.createElement('div');
    newCell.className = 'cell';

    newCell.style.left   = left   + 'px';
    newCell.style.top    = top    + 'px';
    newCell.style.width  = width  + 'px';
    newCell.style.height = height + 'px';

    newCell.style.marginLeft   = marginLeft;
    newCell.style.marginRight  = marginRight;
    newCell.style.marginTop    = marginTop;
    newCell.style.marginBottom = marginBottom;

    if (variableFontSize) {
      newCell.style.fontSize = randomIntegerInclusive(8, 13) + 'px';
    }

    deleteNode(cell1);
    deleteNode(cell2);
    document.body.appendChild(newCell);
  }

  function mergeIfAdjacent(cell1, cell2) {
    if (adjacentHorizontal(cell1, cell2)) {
      merge(cell1, cell2, true);
    } else if (adjacentVertical(cell1, cell2)) {
      merge(cell1, cell2, false);
    }
  }

  function mergeRandomCells(tries) {
    cells = document.getElementsByClassName('cell');

    var cell1 = randomItem(cells);
    var cell2 = randomItem(cells);

    var counter = 0;

    while (! adjacentHorizontal(cell1, cell2) && ! adjacentVertical(cell1, cell2) && counter < tries) {
      cell1 = randomItem(cells);
      cell2 = randomItem(cells);

      counter++;
    }

    mergeIfAdjacent(cell1, cell2);
  }

  function mergeSomeCells(n) {
    for (var i = 0; i < n; i++) {
      mergeRandomCells(100);
    }
  }

  function fillCell(cell, typed) {
    var p = document.createElement('p');
    p.className = 'block';
    cell.appendChild(p);

    var offset = randomIntegerInclusive(0, corpus.length - 1);

    var counter = 0;

    while (! (p.scrollHeight > p.clientHeight)) {
      counter++;
      p.innerHTML = Array.from({length: counter}, (v, i) => corpus[(i + offset) % corpus.length]).join(' ');
    }

    p.innerHTML = Array.from({length: counter - 1}, (v, i) => corpus[(i + offset) % corpus.length]).join(' ');

    if (typed) {
      typeBlock();
    }

    function typeBlock() {
      var blockWithSpans = p.innerHTML.replace(/ /g, '</span> <span>').replace(/-/g, '</span><span>-</span><span>');
      blockWithSpans = '<span>' + blockWithSpans + '</span>';
      p.innerHTML = blockWithSpans;

      var spans = p.getElementsByTagName('span');

      var layout = separateArray(spans, function(a, b, i) {
        return a.getBoundingClientRect().y != b.getBoundingClientRect().y;
      });

      var lines = layout.map(function (line) {
        return line.map(span => span.innerHTML).join(' ').replace(/ *- */g, '-');
      });

      deleteNode(p);

      for (var i = 0; i < lines.length; i++) {
        (function(i) {
          setTimeout(function() {
            var line = document.createElement('div');
            line.className = 'line';
            line.innerHTML = '';
            cell.appendChild(line);
            var lineLength = lines[i].length;

            if (! splitCorpusByWords) {
              if (i == lines.length - 1) {
                line.style.textAlignLast = 'right';
              }
            }

            typeLine();

            function typeLine() {
              if (line.innerHTML.length < lineLength) {
                if (typeDirection) {
                  line.innerHTML = lines[i].slice(0, line.innerHTML.length + 1);
                } else {
                  line.innerHTML = lines[i].slice(-(line.innerHTML.length + 1));
                }
                setTimeout(typeLine, lineDuration / lineLength);
              }
            }
          }, paragraphDuration / lines.length * i);
        })(i);
      }
    }
  }

  function fillAllCells(typed) {
    cells = document.getElementsByClassName('cell');

    for (var i = 0; i < cells.length; i++) {
      if (typed) {
        fillCell(cells[i], true);
      } else {
        fillCell(cells[i], false);
      }
    }
  }

  function clearCell(cell) {
    var lines = cell.getElementsByClassName('line');

    for (var i = 0; i < lines.length; i++) {
      (function(i) {
        setTimeout(function() {

          var lineLength = lines[i].length;
          untypeLine();

          function untypeLine() {
            if (lines[i].innerHTML.length > 0) {
              if (untypeDirection) {
                lines[i].innerHTML = lines[i].innerHTML.slice(0, -1);
              } else {
                lines[i].innerHTML = lines[i].innerHTML.slice(1);
              }
              setTimeout(untypeLine, lineDuration / lineLength);
            }
          }
        }, paragraphDuration / lines.length * (lines.length - i));
      })(i);
    }

    function deleteWhenDone() {
      setTimeout(function() {
        if (cell.textContent.length == 0) {
          deleteNode(cell);
        } else {
          deleteWhenDone();
        }
      }, 100);
    }

    deleteWhenDone();
  }

  function clearGrid() {
    cells = document.getElementsByClassName('cell');

    for (var i = 0; i < cells.length; i++) {
      clearCell(cells[i]);
    }
  }

  function deleteNode(node) {
    node.parentNode.removeChild(node);
  }
</script>

</html>